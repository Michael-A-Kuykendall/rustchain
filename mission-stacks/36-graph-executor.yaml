# ðŸ”€ Mission 36 â€” Graph Executor for DAG Missions
# Enables dependency-based task execution with topological sort.
# Affects: engine/graph_executor.rs, lib.rs

file: engine/graph_executor.rs
---
use std::collections::{HashMap, HashSet, VecDeque};

#[derive(Debug, Clone)]
pub struct TaskNode {
    pub id: String,
    pub depends_on: Vec<String>,
    pub params: HashMap<String, String>,
}

pub struct GraphExecutor {
    pub tasks: HashMap<String, TaskNode>,
}

impl GraphExecutor {
    pub fn new() -> Self {
        Self {
            tasks: HashMap::new(),
        }
    }

    pub fn add_task(&mut self, task: TaskNode) {
        self.tasks.insert(task.id.clone(), task);
    }

    pub fn resolve_order(&self) -> Result<Vec<String>, String> {
        let mut in_degree = HashMap::new();
        for task in self.tasks.values() {
            in_degree.entry(task.id.clone()).or_insert(0);
            for dep in &task.depends_on {
                *in_degree.entry(dep.clone()).or_insert(0) += 1;
            }
        }

        let mut queue = VecDeque::new();
        for (id, &deg) in &in_degree {
            if deg == 0 {
                queue.push_back(id.clone());
            }
        }

        let mut order = vec![];
        let mut visited = HashSet::new();

        while let Some(node) = queue.pop_front() {
            order.push(node.clone());
            visited.insert(node.clone());

            for t in self.tasks.values() {
                if t.depends_on.contains(&node) {
                    let entry = in_degree.get_mut(&t.id).unwrap();
                    *entry -= 1;
                    if *entry == 0 {
                        queue.push_back(t.id.clone());
                    }
                }
            }
        }

        if visited.len() != self.tasks.len() {
            Err("Cycle detected in task graph".to_string())
        } else {
            Ok(order)
        }
    }
}
---

file: lib.rs
---
pub mod graph_executor;
---
